import java.util.ArrayList;
import java.util.List;

public class EdifObject {
    private String name;
    private ContextObj context;
    private List<Object> params;

    public EdifObject(String name) {
        this.name = name;
        this.context = ContextObj.getValue(name.toLowerCase());
        this.params = new ArrayList<>();
    }

    public void addParam(Object param) {
        this.params.add(param);
    }

    public Object getParam(int index) {
        return this.params.get(index);
    }

    public List<Object> getParams() {
        return this.params;
    }

    public List<Object> getParams(List<Integer> indexes) {
        List<Object> result = new ArrayList<>();
        for (int index : indexes) {
            result.add(this.getParam(index));
        }
        return result;
    }

    public int getNbParam() {
        return this.params.size();
    }

    public String output() {
        StringBuilder sb = new StringBuilder();
        sb.append("(").append(this.context.getName());
        for (Object param : this.params) {
            if (param instanceof EdifObject) {
                sb.append(((EdifObject) param).output());
            } else {
                sb.append(" ").append(param);
            }
        }
        sb.append(")");
        return sb.toString();
    }

    public String getContext() {
        return this.context.getName();
    }

    private EdifObject getObject(String contextName) {
        for (Object item : this.params) {
            if (item instanceof EdifObject) {
                EdifObject edifObject = (EdifObject) item;
                if (contextName.toLowerCase().equals(edifObject.getContext())) {
                    return edifObject;
                }
            }
        }
        return null;
    }

    public EdifObject getObject(String contextPath, boolean abortOnError) {
        String[] contextList = contextPath.split("\\.");
        EdifObject currentObj = this;
        for (String contextName : contextList) {
            EdifObject tmpObj = currentObj.getObject(contextName);
            if (tmpObj == null) {
                if (abortOnError) {
                    System.out.println("*** ERROR : key '" + contextName + "' unknown in '" + currentObj.getContext() + "' !");
                    System.exit(1);
                } else {
                    return null;
                }
            } else {
                currentObj = tmpObj;
            }
        }
        return currentObj;
    }

    public EdifObject getObjectParam(String contextName, Object param0) {
        EdifObject obj = this.getObject(contextName);
        if (obj != null) {
            if (obj.getParam(0).equals(param0)) {
                return obj;
            }
        }
        return null;
    }

    public void findObjects(String contextName, List<EdifObject> result) {
        for (Object item : this.params) {
            if (item instanceof EdifObject) {
                EdifObject edifObject = (EdifObject) item;
                if (contextName.toLowerCase().equals(edifObject.getContext())) {
                    result.add(edifObject);
                }
                edifObject.findObjects(contextName, result);
            }
        }
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + "_" + this.getContext();
    }
}

public class EdifParser {
    private static final String[] CONTEXT_DEF = {
            "",
            "acload",
            "after",
	"annotate",
	"apply",
	"arc",
	"array",
	"arraymacro",
	"arrayrelatedinfo",
	"arraysite",
	"atleast",
	"atmost",
	"author",
	"basearray",
	"becomes",
	"between",
	"boolean",
	"booleandisplay",
	"booleanmap",
	"borderpattern",
	"borderwidth",
	"boundingbox",
	"cell",
	"cellref",
	"celltype",
	"change",
	"circle",
	"color",
	"comment",
	"commentgraphics",
	"compound",
	"connectlocation",
	"contents",
	"cornertype",
	"criticality",
	"currentmap",
	"curve",
	"cycle",
	"dataorigin",
	"dcfaninload",
	"dcfanoutload",
	"dcmaxfanin",
	"dcmaxfanout",
	"delay",
	"delta",
	"derivation",
	"design",
	"designator",
	"difference",
	"direction",
	"display",
	"dominates",
	"dot",
	"duration",
	"e",
	"edif",
	"ediflevel",
	"edifversion",
	"enclosuredistance",
	"endtype",
	"entry",
	"exactly",
	"external",
	"fabricate",
	"false",
	"figure",
	"figurearea",
	"figuregroup",
	"figuregroupobject",
	"figuregroupoverride",
	"figuregroupref",
	"figureperimeter",
	"figurewidth",
	"fillpattern",
	"follow",
	"forbiddenevent",
	"globalportref",
	"greaterthan",
	"gridmap",
	"ignore",
	"includefiguregroup",
	"initial",
	"instance",
	"instancebackannotate",
	"instancegroup",
	"instancemap",
	"instanceref",
	"integer",
	"integerdisplay",
	"interface",
	"interfiguregroupspacing",
	"intersection",
	"intrafiguregroupspacing",
	"inverse",
	"isolated",
	"joined",
	"justify",
	"keyworddisplay",
	"keywordlevel",
	"keywordmap",
	"lessthan",
	"library",
	"libraryref",
	"listofnets",
	"listofports",
	"loaddelay",
	"logicassign",
	"logicinput",
	"logiclist",
	"logicmapinput",
	"logicmapoutput",
	"logiconeof",
	"logicoutput",
	"logicport",
	"logicref",
	"logicvalue",
	"logicwaveform",
	"maintain",
	"match",
	"member",
	"minomax",
	"minomaxdisplay",
	"mnm",
	"multiplevalueset",
	"mustjoin",
	"name",
	"net",
	"netbackannotate",
	"netbundle",
	"netdelay",
	"netgroup",
	"netmap",
	"netref",
	"nochange",
	"nonpermutable",
	"notallowed",
	"notchspacing",
	"number",
	"numberdefinition",
	"numberdisplay",
	"offpageconnector",
	"offsetevent",
	"openshape",
	"orientation",
	"origin",
	"overhangdistance",
	"overlapdistance",
	"oversize",
	"owner",
	"page",
	"pagesize",
	"parameter",
	"parameterassign",
	"parameterdisplay",
	"path",
	"pathdelay",
	"pathwidth",
	"permutable",
	"physicaldesignrule",
	"plug",
	"point",
	"pointdisplay",
	"pointlist",
	"polygon",
	"port",
	"portbackannotate",
	"portbundle",
	"portdelay",
	"portgroup",
	"portimplementation",
	"portinstance",
	"portlist",
	"portlistalias",
	"portmap",
	"portref",
	"program",
	"property",
	"propertydisplay",
	"protectionframe",
	"pt",
	"rangevector",
	"rectangle",
	"rectanglesize",
	"rename",
	"resolves",
	"scale",
	"scalex",
	"scaley",
	"section",
	"shape",
	"simulate",
	"simulationinfo",
	"singlevalueset",
	"site",
	"socket",
	"socketset",
	"status",
	"steady",
	"string",
	"stringdisplay",
	"strong",
	"symbol",
	"symmetry",
	"table",
	"tabledefault",
	"technology",
	"textheight",
	"timeinterval",
	"timestamp",
	"timing",
	"transform",
	"transition",
	"trigger",
	"true",
	"unconstrained",
	"undefined",
	"union",
	"unit",
	"unused",
	"userdata",
	"version",
	"view",
	"viewlist",
	"viewmap",
	"viewref",
	"viewtype",
	"visible",
	"voltagemap",
	"wavevalue",
	"weak",
	"weakjoined",
	"when",
	"written"
    };

    private static final ContextObj CONTEXT_OBJ = new ContextObj("Context", CONTEXT_DEF);

    public static class ContextObj {
        private String enumName;
        private String[] listValueNames;
        private Class<?>[] listValueTyped;
        private Map<String, Class<?>> dictAttrib;
        private Map<Class<?>, String> dictReverse;

        public ContextObj(String enumName, String[] listValueNames) {
            this.enumName = enumName;
            this.listValueNames = listValueNames;
            this.listValueTyped = new Class<?>[listValueNames.length];
            for (int i = 0; i < listValueNames.length; i++) {
                this.listValueTyped[i] = Class.forName(enumName + "." + listValueNames[i]);
            }
            this.dictAttrib = new HashMap<>();
            for (int i = 0; i < listValueNames.length; i++) {
                this.dictAttrib.put(listValueNames[i], listValueTyped[i]);
            }
            this.dictReverse = new HashMap<>();
            for (int i = 0; i < listValueNames.length; i++) {
                this.dictReverse.put(listValueTyped[i], listValueNames[i]);
            }
        }

        public Class<?> getValue(String name) {
            Class<?> ret = this.dictAttrib.get(name);
            if (ret == null) {
                System.out.println("*** ERROR unknown object '" + name + "'");
            }
            return ret;
        }

        public String getName(Class<?> value) {
            String ret = this.dictReverse.get(value);
            if (ret == null) {
                System.out.println("*** ERROR unknown type '" + value + "'");
            }
            return ret;
        }
    }

    public static EdifObject parseRecurs(Object data, EdifObject parentObj, int level) {
        if (data instanceof List) {
            List<?> items = (List<?>) data;
            int nextLevel = level + 1;

            EdifObject currentObj = null;
            int ix = 0;
            for (Object item : items) {
                if (ix == 0) {
                    String name = item.toString();
                    currentObj = new EdifObject(name);
                } else {
                    if (currentObj != null) {
                        parseRecurs(item, currentObj, nextLevel);
                    }
                }
                ix++;
            }
            return currentObj;
        } else {
            return data.toString();
        }
    }

    public static EdifObject readEdifFile(String filename) {
        File file = new File(filename);
        if (!file.exists()) {
            System.out.println("Le fichier " + filename + " n'existe pas");
            return null;
        }
        try {
            String content = new String(Files.readAllBytes(file.toPath()));
            Object data = loads(content);

            EdifObject edifRoot = new EdifObject("");
            parseRecurs(data, edifRoot, 0);

            return edifRoot;
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    public static List<EdifObject> searchEdifObjects(EdifObject parentObj, String contextName) {
        List<EdifObject> objects = new ArrayList<>();
        parentObj.findObjects(contextName, objects);
        return objects;
    }

    public static List<Object> extractEdifStrParam(EdifObject object, int index) {
        Object p1 = object.getParam(index);
        if (p1 instanceof String) {
            String string = (String) p1;
            return Arrays.asList(string, string);
        } else {
            String paramType = ((EdifObject) p1).getContext();
            if (paramType.equals("rename")) {
                Object definition = ((EdifObject) p1).getParam(0);
                String string = (String) ((EdifObject) p1).getParam(1);
                return Arrays.asList(definition, string);
            } else if (paramType.equals("name")) {
                String string = (String) ((EdifObject) p1).getParam(0);
                return Arrays.asList(p1, string);
            }
        }
        return null;
    }

    public static List<Integer> extractEdifPt(EdifObject pt) {
        if (pt != null) {
            int ptX = Integer.parseInt((String) pt.getParam(0));
            int ptY = Integer.parseInt((String) pt.getParam(1));
            return Arrays.asList(ptX, ptY);
        } else {
            return null;
        }
    }
}